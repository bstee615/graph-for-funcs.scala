/* graph-for-funcs.scala

  This script returns a Json representation of the graph resulting in combining the
  AST, CGF, and PDG for each method contained in the currently loaded CPG.

  Updated for Joern v1.1.590  (https://github.com/joernio/joern/releases/tag/v1.1.590).

  Input: A valid CPG
  Output: Json

  Running the Script
  ------------------
  Usage: joern --script=graph-for-funcs.scala --params=sourceCode=<path/to/project>,outFile=<path/to/output.json>

  The JSON generated has the following keys:

  "file": The file (as full path) the CPG was generated from
  "functions": Array of all methods contained in the currently loaded CPG
    |_ "function": Method name as String
    |_ "id": Method id as String (String representation of the underlying Method node)
    |_ "AST": AST nodes
    |_ "CFG": AST nodes
    |_ "PDG": PDG nodes
  
  Each node has the following keys:
  "id": Unique ID of the node, generated by Joern
  "edges": Array of all edges into/out of the node
    |_ "id": Unique ID of the edge, generated by Joern
    |_ "in": Unique ID of the node into which this edge is pointing
    |_ "out": Unique ID of the node from which this edge is pointing
  "properties": Dict of all property names and their corresponding values
    |_ "key": Property key
    |_ "value": Corresponding property value

*/

import scala.collection.JavaConverters._

import io.circe.syntax._
import io.circe.generic.semiauto._
import io.circe.{Encoder, Json}

import io.shiftleft.codepropertygraph.generated.EdgeTypes
import io.shiftleft.codepropertygraph.generated.NodeTypes
import io.shiftleft.codepropertygraph.generated.nodes
import io.shiftleft.codepropertygraph.generated.nodes.MethodParameterIn
import collection.JavaConverters._

final case class GraphForFuncsFunction(function: String,
                                       id: String,
                                       AST: List[nodes.AstNode],
                                       CFG: List[nodes.AstNode],
                                       PDG: List[nodes.AstNode])
final case class GraphForFuncsResult(file: String, functions: List[GraphForFuncsFunction])


@main def exec(sourceCode: String, outFile: String) = {
    importCode.c(sourceCode)
    run.ossdataflow
    
    val edges = cpg.graph.E.hasLabel("AST", "CFG").l

    implicit val encodeEdge: Encoder[Edge] =
      (edge: Edge) =>
        Json.obj(
          ("id", Json.fromString(edge.toString)),
          ("in", Json.fromString(edge.inNode.toString)),
          ("out", Json.fromString(edge.outNode.toString))
        )

    implicit val encodeNode: Encoder[nodes.AstNode] =
      (node: nodes.AstNode) =>
        Json.obj(
          ("id", Json.fromString(node.toString)),
          ("edges",
            Json.fromValues(
              edges.collect {
                case e if e.inNode == node  => e
                case e if e.outNode == node => e
              }.map(_.asJson))),
          ("properties", Json.fromValues((node.propertiesMap: MapHasAsScala[String, Object]).asScala.map { p =>
            Json.obj(
              ("key", Json.fromString(p._1)),
              ("value", Json.fromString(p._2.toString))
            )
          }))
        )

    implicit val encodeFuncFunction: Encoder[GraphForFuncsFunction] = deriveEncoder
    implicit val encodeFuncResult: Encoder[GraphForFuncsResult] = deriveEncoder
   
    GraphForFuncsResult(
    cpg.file.name.l.head,
    cpg.method.map { method =>
        val methodName = method.fullName
        val methodId = method.toString

        val astChildren = method.astMinusRoot.l

        val cfgChildren = method.astMinusRoot.filter(_.isInstanceOf[nodes.CfgNode]).cast[nodes.CfgNode].l

        val pdgChildren = {
            var pdgChildren: List[CfgNode] = List()
            val local = method.out(EdgeTypes.CONTAINS).hasLabel(NodeTypes.BLOCK).out(EdgeTypes.AST).hasLabel(NodeTypes.LOCAL).cast[nodes.Local]
            val sink = local.evalType(".*").referencingIdentifiers.l
            if (sink.length > 0) {
                val source = cpg.method.parameter

                (sink
                    .reachableByFlows(source)
                    .l
                    .flatMap{ path =>
                        path.elements.map {
                            case trackingPoint @ (_: MethodParameterIn) => trackingPoint.start.method.head
                            case trackingPoint                          => trackingPoint
                        }
                    }
                    .filter(_.toString != methodId)
                )
            }
            else {
                List()
            }
        }

        GraphForFuncsFunction(methodName, methodId, astChildren, cfgChildren, pdgChildren)
    }.l
    ).asJson.toString |> outFile
}
